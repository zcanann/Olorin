/// This file contains every binding between the UI (view) and Rust (view-model).
/// The MVVM pattern is really simple. You have:
/// - A view (.slint files)
/// - A model (squalr libraries)
/// - And a view-model (glue that connects the two)
/// The bindings below are how the view <=> view-model connect to one another.

export global WindowViewModelBindings {
    callback close();
    callback maximize();
    callback minimize();
    callback double-clicked();
    callback drag(int, int);
}

export struct DockedWindowData {
    identifier: string,
    is-docked: bool,
    position-x: length,
    position-y: length,
    width: length,
    height: length,
}

export global DockedWindowViewModelBindings {
    callback close();
    callback maximize();
    callback minimize();
    callback double-clicked();
    callback drag-left(string, int, int);
    callback drag-right(string, int, int);
    callback drag-top(string, int, int);
    callback drag-bottom(string, int, int);
    in-out property <DockedWindowData> scan-results-panel;
    in-out property <DockedWindowData> output-panel;
    in-out property <DockedWindowData> process-selector-panel;
    in-out property <DockedWindowData> property-viewer-panel;
    in-out property <DockedWindowData> project-explorer-panel;
    in-out property <DockedWindowData> settings-panel;
}

export struct ProcessViewData {
    name: string,
    icon: image,
}

export global ProcessViewModelBindings {
    callback open-process(int);
    in property <[ProcessViewData]> processes;
}

export global OutputViewModelBindings {
    in-out property <string> output-text;
}

export global ScanViewModelBindings {
    callback new_scan();
    callback set_scan_constraint(int);
}

export global MemorySettingsViewModelBindings {
    in-out property <bool> memory_type_none;
    callback memory_type_none_changed(bool);
    in-out property <bool> memory_type_private;
    callback memory_type_private_changed(bool);
    in-out property <bool> memory_type_image;
    callback memory_type_image_changed(bool);
    in-out property <bool> memory_type_mapped;
    callback memory_type_mapped_changed(bool);
    in-out property <bool> required_write;
    callback required_write_changed(bool);
    in-out property <bool> required_execute;
    callback required_execute_changed(bool);
    in-out property <bool> required_copy_on_write;
    callback required_copy_on_write_changed(bool);
    in-out property <bool> excluded_write;
    callback excluded_write_changed(bool);
    in-out property <bool> excluded_execute;
    callback excluded_execute_changed(bool);
    in-out property <bool> excluded_copy_on_write;
    callback excluded_copy_on_write_changed(bool);
    in-out property <string> start_address;
    callback start_address_changed(string);
    in-out property <string> end_address;
    callback end_address_changed(string);
    in-out property <bool> only_query_usermode;
    callback only_query_usermode_changed(bool);
}

export global ScanSettingsViewModelBindings {
    in-out property <int> results_page_size;
    callback results_page_size_changed(int);
    in-out property <int> results_read_interval;
    callback results_read_interval_changed(int);
    in-out property <int> table_read_interval;
    callback table_read_interval_changed(int);
    in-out property <int> freeze_interval;
    callback freeze_interval_changed(int);
    // Option<MemoryAlignment>,
    in-out property <int> memory_alignment;
    callback memory_alignment_changed(int);
    // FloatingPointTolerance,
    in-out property <int> floating_point_tolerance;
    callback floating_point_tolerance_changed(int);
}

export global ProjectExplorerViewModelBindings { }

export global ScanResultsViewModelBindings { }

export global PointerScanResultsViewModelBindings { }

export global PropertyViewerViewModelBindings { }
